<!DOCTYPE html>
<html lang="zh-cn">
    <head prefix="og: https://ogp.me/ns#">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="color-scheme" content="light dark">
  <meta name="baidu-site-verification" content="codeva-fKqX8ua7ka" />
  <link rel="apple-touch-icon" sizes="76x76" href="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-oss/4/files/512.jpg">
  
  <title>为什么我更想要FullCone网络 - CyanFalse&#39;s HomeRegion</title>
  
    <link rel="shortcut icon" href="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-oss/6.0.0/files/32.png">
  
  

  
  
  
  <meta property="og:title" content="为什么我更想要FullCone网络 - CyanFalse&#39;s HomeRegion" />
  
  <meta property="og:type" content="article" />
  
  <meta property="og:url" content="https://blog.eurekac.cn/p/daa17206.html" />
  
  <meta property="og:image" content="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/banner/why-i-prefer-fullcone.jpg" />
  
  <meta property="og:article:published_time" content="2024-02-15T20:15:42.000Z" />
  
  <meta property="og:article:author" content="CyanFalse" />
  
  
  <link rel="stylesheet" href='/css/var.css'>
  <link rel="stylesheet" href='/css/main.css'>
  <link rel="stylesheet" href='/css/typography.css'>
  <link rel="stylesheet" href='/css/code-highlighting.css'>
  <link rel="stylesheet" href='/css/components.css'>
  <link rel="stylesheet" href='/css/nav.css'>
  <link rel="stylesheet" href='/css/paginator.css'>
  <link rel="stylesheet" href='/css/footer.css'>
  <link rel="stylesheet" href='/css/post-list.css'>
  
  
  <link rel="stylesheet" href='/css/toc.css'>
  
  
  
  
  <link rel="stylesheet" href='/css/post.css'>
  
  
  
  
  
  <!-- <link rel="stylesheet" href="https://cdn.eurekac.cn/npm/lxgw-wenkai-webfont/1.1.0/files/style.css" /> -->
  
    <link rel="stylesheet" href="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174143/files/data/npm/@fancyapps/ui/4.0.31/files/dist/fancybox.css" />
  
  

  <link rel="stylesheet" href="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174143/files/data/npm/notyf/3.10.0/files/notyf.min.css">
<meta name="generator" content="Hexo 6.3.0"></head>
    
    <body
        data-color-scheme="auto"
        data-uppercase-categories="true"
        
        data-config-root="/"
        
        data-toc="true"
        data-toc-max-depth="4"
        
        
    >
        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">
            Eureka Cyan!
        </a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">
                主页
            </a>
            
                <a class="nav-item" href="/archives/">
                    归档
                </a>
                
                <a class="nav-item" href="/friends/">
                    友链
                </a>
                
                <a class="nav-item" href="/categories/">
                    分类
                </a>
                
                <a class="nav-item" target="_blank" rel="noopener" href="https://eurekac.cn">
                    项目主页
                </a>
                
                <a class="nav-item" href="/CyanAcc/#/dashboard">
                    设置
                </a>
                
                    <span>
                        <a class="nav-item nav-item-search nav-item-icon" href="/search" target="_blank"
                            aria-label="Search" one-link-mark="yes">&nbsp;</a>
                            <!-- <div class="color-scheme-toggle" role="radiogroup" id="theme-color-scheme-toggle">
                                <label>
                                    <input type="radio" value="light">
                                    <span>Light</span>
                                </label>
                                <label>
                                    <input type="radio" value="dark">
                                    <span>Dark</span>
                                </label>
                                <label>
                                    <input type="radio" value="auto">
                                    <span>Auto</span>
                                </label>
                            </div> -->
                    </span>
        </div>
    </div>
</nav>
        
<article class="post">
    <canvas id='map'></canvas>
    <div class="meta">
        
        <div class="categories text-uppercase">
        
            <a href="/categories/随心扯/">随心扯</a>
        
        </div>
        

        
        <div class="date" id="date">
            <span>February</span>
            <span>15,</span>
            <span>2024</span>
        </div>
        

        <h2 class="title">为什么我更想要FullCone网络</h2>
    </div>

    <div class="divider"></div>

    <div class="content">
        <p>FullCone是什么？我是如何利用FullCone网络实现内网穿透的？为什么我会这么希望得到全锥网络？</p>
<span id="more"></span>

<hr>
<p>寒假的时候几个高中同学凑一块，想联机玩Minecraft。然而我们几个同学都没有公网ip，想要联机必须要内网穿透。</p>
<blockquote>
<p>为什么不用IPV6？因为除了我之外其他人的路由器都是NAT在运营商给的智慧网关下，而智慧网关并不支持在NAT中分配IPV6。</p>
</blockquote>
<p>传统内网穿透，本质上是用户之间无法直接连接，只能通过一台大家都能连上的服务器互相转发流量，达到穿透的目的。</p>
<p>显而易见，这种方式的互联受限于服务器的带宽和延迟，而且为了转发流量而单独购买一台服务器并不值得。</p>
<p>有没有一种方式，能让两个相互处于NAT网络的用户直接连接，而不需要服务器转发流量呢？</p>
<p>在这之前，我们不妨回过头来，聊聊生活中司空见惯的NAT技术。</p>
<h2 id="What-is-NAT"><a href="#What-is-NAT" class="headerlink" title="What is NAT"></a>What is NAT</h2><p>NAT(Network Address Translation)是网络地址转换的缩写，是一种将私有网络地址转换为公有网络地址的技术，诞生的目的是为了解决IPv4地址不足的问题。其解决方案是将多个设备处于一个局域网内，通过共享一个公网ip地址来访问外部网络。</p>
<p>一个传统的网络链接，本质上是两个（ip地址:端口）之间的通讯。NAT通过类似中间人的方式，转发了（公网ip:端口）和（内网ip:端口）之间的通讯。</p>
<p><a href="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/1.png" data-fancybox="gallery" data-caption="图源来自维基百科">
            <img src="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/1.png" class="lazy" data-srcset="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="图源来自维基百科">
            </a></p>
<p>不妨用我访问<code>https://baidu.com</code>的过程来举例：</p>
<ol start="0">
<li>路由器通过拨号上网，获取到了一个公网ip地址<code>39.0.0.1</code>。路由器网关为<code>192.168.1.0</code>，我的电脑ip为<code>192.168.1.1</code>。</li>
<li>浏览器通过DNS解析获取到百度的ip为<code>110.242.68.66</code>，由于我采用<code>https</code>，故默认访问端口为<code>443</code>，则目标pair为<code>110.242.68.66:443</code></li>
<li>浏览器通过网卡，查询到本机ip为<code>192.168.1.1</code>，并在本地打开了一个临时端口<code>12345</code>，将数据包发送给网关<code>192.168.1.0</code></li>
<li>路由器接收到来自<code>192.168.1.1:12345 -&gt; 110.242.68.66:443</code>的请求。</li>
<li>路由器在本地打开了一个临时端口<code>54321</code>，将请求改写为<code>39.0.0.1:54321 -&gt; 110.242.68.66:443</code>，并将请求数据包发送给百度服务器。同时，路由器在本地记录了这个pair的映射关系<code>39.0.0.1:54321 -&gt; 192.168.1.1:12345</code>。</li>
<li>路由器接收到来自百度的返回消息<code>110.242.68.66:443 -&gt; 39.0.0.1:54321</code>，通过查询映射关系，将返回消息改写为<code>110.242.68.66:443 -&gt; 192.168.1.1:12345</code>，并发送给<code>192.168.1.1</code>。</li>
</ol>
<p>通过NAT技术，处在内网的用户能够主动向外部网络发起请求，并且由于路由器保持了映射关系，外部网络也能够向内网发送数据。</p>
<p>但是，在这一情况下外部网络并不能主动向内网发起请求。由于外部网络发出请求数据后，路由表内并没有对应的pair映射关系，路由器并不知晓将外部请求转发给哪个内网用户，会直接丢弃。这就造成了内网用户可以主动链接外部网络，而外部网络却不能主动链接内网用户的局面。</p>
<p>别急，让我们重新审视一下这个过程中最关键的部分：<strong>路由器在本地记录了映射关系</strong>，这才能允许外网向内网发送数据。</p>
<p>如果想要达到外网主动链接内网的目的，由于映射关系只能通过内网用户发起请求或者路由器主动打开，我们的思路应该着重于如何主动获取并保持这个映射关系。</p>
<p>映射关系在内网用户主动发起请求的时候建立，而销毁映射关系的策略则略有不同。由于TCP链接为有状态的链接，路由器会在链接主动关闭时自动销毁映射关系。而UDP链接则不同，由于UDP链接是无状态的，路由器并不知晓何时销毁映射关系，只能通过一定的策略来销毁。这一策略通常是在一段时间内没有数据包通过时销毁映射关系。换句话说，在建立映射关系后，只要不断地发送心跳包，这一映射关系就能够一直保持。</p>
<p>回头来看，这一问题的解决方案就显而易见了，在建立一个请求后通过不断发送心跳包，欺骗路由器，使其保持映射关系，就能够实现外网主动链接内网的目的。</p>
<p>…吗？</p>
<h2 id="NAT-has-4-main-types"><a href="#NAT-has-4-main-types" class="headerlink" title="NAT has 4 main types"></a>NAT has 4 main types</h2><p>回头来看，事情的解决好像变得太过于简单了。固然，映射关系能够使发送至<code>39.0.0.1:54321</code>的数据包转发到<code>192.168.1.1:12345</code>，在百度的视角来看，我就像是拥有了公网ip，能够主动向<code>39.0.0.1:54321</code>发送信息。</p>
<p>然而，NAT技术很早就考虑到了这一点。映射关系的存在固然能够使外网主动链接内网，但这使得内网用户的（ip地址:端口）彻底暴露在了外网之中。而NAT的本身是局域网，起到了与外部网络隔离的作用，这种暴露方式即不优雅，也不安全。</p>
<p>至此，NAT根据转发策略和限制映射关系访问的方式，分为了4种类型（RFC3489）：</p>
<ul>
<li>FullCone 全锥，映射对能够被任意外部网络访问（也被称为NAT A）</li>
<li>RestrictedCone 限制锥，映射对仅能被映射目标ip访问（丢弃除了来自<code>110.242.68.66</code>的所有数据包）</li>
<li>PortRestrictedCone 端口限制锥，映射对仅能被映射目标ip和端口访问（丢弃除了来自<code>110.242.68.66:443</code>的所有数据包）</li>
<li>Symmetric 对称，映射对仅能被映射目标ip和端口访问，并且当目的地ip和端口不同时，映射对也会不同（即使内网ip:端口是相同的）</li>
</ul>
<p>其中 全锥、限制锥、端口限制锥 最大的特征是同一个（内网ip:端口）的映射请求会被映射为相同的（公网ip:端口），无论目的地ip和端口是什么。而 对称 则会在目的地ip和端口不同时映射为不同的（公网ip:端口）。</p>
<p>你可以用Python的pystun3来测试你的NAT类型：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install pystun3</span><br><span class="line">pystun3</span><br><span class="line">pystun3 -H stun.qq.com #国内用户可以指定qq的stun服务器以加快测试速度</span><br></pre></td></tr></table></figure>

<p>返回数据应该如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAT Type: Full Cone</span><br><span class="line">External IP: 39.0.0.1</span><br><span class="line">External Port: 12463</span><br></pre></td></tr></table></figure>

<h2 id="Let-us-have-a-try-to-build-up-a-server-with-FullCone-NAT"><a href="#Let-us-have-a-try-to-build-up-a-server-with-FullCone-NAT" class="headerlink" title="Let us have a try - to build up a server with FullCone NAT"></a>Let us have a try - to build up a server with FullCone NAT</h2><p>知道了原理，不来试试怎么加深理解呢？</p>
<p>首先，以下操作需要一个拥有全锥NAT的网络环境。如果没有你可以看下一节内容尝试将自己的家庭网络改造为全锥NAT。</p>
<p>此外，需要一台拥有公网ip的服务器，以便于本地计算机能够探测出映射关系。</p>
<p>接下来，我将展示两个脚本，通过运行脚本，本地计算机能够探测出映射关系并在映射对上建立一个临时服务器，如果外部网络能够通过探测出来的映射对访问到这个临时服务器，那么就能证明FullCone内网穿透理论可行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> ip = req.<span class="property">connection</span>.<span class="property">remoteAddress</span>.<span class="title function_">match</span>(<span class="regexp">/\d+\.\d+\.\d+\.\d+/</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> port = req.<span class="property">connection</span>.<span class="property">remotePort</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Request from <span class="subst">$&#123;ip&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> req = http.<span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">host</span>: ip,</span><br><span class="line">        <span class="attr">port</span>: port,</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">      req.<span class="title function_">end</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123; &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>); <span class="comment">//该定时器会每秒向客户端发送一个请求，使得映射关系不会因为长时间没有通信而被销毁，从而实现锁定映射关系</span></span><br><span class="line">  res.<span class="title function_">end</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; ip, port &#125;));</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">13000</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> localPort = <span class="number">18000</span>; <span class="comment">//这是本地即将暴露的端口</span></span><br><span class="line"><span class="keyword">const</span> endpoint_url = <span class="string">&#x27;&#x27;</span> <span class="comment">//这是部署了server.js的服务器的ip地址</span></span><br><span class="line"><span class="keyword">const</span> endpoint_port = <span class="number">13000</span> <span class="comment">//这是部署了server.js的服务器的端口</span></span><br><span class="line"><span class="keyword">const</span> req = http.<span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">host</span>: endpoint_url,</span><br><span class="line">    <span class="attr">port</span>: endpoint_port,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">localPort</span>: localPort <span class="comment">//http.request可以通过localPort参数强制指定本地端口</span></span><br><span class="line">&#125;, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; ip, port &#125; = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(data.<span class="title function_">toString</span>());</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`127.0.0.1:<span class="subst">$&#123;localPort&#125;</span> -&gt; <span class="subst">$&#123;ip&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`http://<span class="subst">$&#123;ip&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">        http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">            res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span> &#125;);</span><br><span class="line">            res.<span class="title function_">end</span>(<span class="string">`Working at <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>`</span>);</span><br><span class="line">        &#125;).<span class="title function_">listen</span>(localPort); <span class="comment">//通过server.js探测到映射对，然后在本地启动一个服务器，外网访问ip:port会被映射到本地的localPort，从而实现了内网穿透</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">req.<span class="title function_">end</span>();</span><br></pre></td></tr></table></figure>

<p>先运行server.js，然后填入服务器的ip，再运行client.js，控制台内有如下输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:18000 -&gt; 39.1.1.1:12319</span><br><span class="line">http://39.1.1.1:12319</span><br></pre></td></tr></table></figure>

<p>脚本将会自动在<code>0.0.0.0:18000</code>启动一个测试服务器，我们直接点击链接访问<code>http://39.1.1.1:12319</code></p>
<p><a href="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/1.jpg" data-fancybox="gallery" data-caption="该图片无描述">
            <img src="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/1.jpg" class="lazy" data-srcset="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==">
            </a></p>
<p>如果显示了信息，说明我们的<code>127.0.0.1:18000</code>已经成功地被穿透到了<code>39.1.1.1:12319</code>。</p>
<p>并且，将<code>http://39.1.1.1:12319</code>分享给其他人，他们也能够访问到你的本地服务器。</p>
<p>请注意，从头到尾我并没有声明我拥有公网ip，事实上，无论是否为公网ip，只要nat类型为FullCone，都可以利用这种方式穿透。</p>
<p>使用FullCone穿透的地址可以直接被外网访问，其优点在于流量无需服务器中转，最终的访问是点对点的，目标用户是直接访问到内网的服务器，延迟和速率不受限制。探测服务器仅用于辅助内网用户获取到自己链路上的映射对，本身不参与网络连接。并且网络上存在大量的免费探测服务器，不一定需要自己搭建的服务器。</p>
<p>缺点也十分明显，映射对本身需要长时间的心跳包才能维持，一旦映射长时间无数据包通过，映射就会被断掉，并且重新映射的端口不固定。此外，如果作为长期暴露在公网上供他人访问，还是需要有其他方法将探测到的映射对共享出去（类似DDNS）。</p>
<h2 id="STUN-A-formal-protocol-to-detect-NAT-pair"><a href="#STUN-A-formal-protocol-to-detect-NAT-pair" class="headerlink" title="STUN - A formal protocol to detect NAT pair"></a>STUN - A formal protocol to detect NAT pair</h2><p>事实上，上面的脚本只是一个简单的例子。然而，RFC5389定义了一种更加正式的协议，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/STUN">STUN(Session Traversal Utilities for NAT)</a>。STUN协议定义了一种用于检测NAT类型和获取映射对的协议，其探测协议为UDP。由于基于UDP的探测对不会在断开连接后立刻销毁，STUN协议能够有更大的成功率实现NAT互联。</p>
<blockquote>
<p>需要注意的是，部分路由器在建立映射对的时候也会限制协议。如果内网内用户用UDP探测，则部分路由器只会允许UDP协议的映射对，而不会允许TCP数据包通过映射对。反之亦然。</p>
<p>如同上面的Demo中，我利用TCP协议来探测映射对，因此外网只能用TCP协议（HTTP协议基于TCP）访问到我的内网服务器，而外网服务器尝试向映射对发送UDP数据包，路由器则会直接丢弃。</p>
<p>然而，我们可以将TCP包装在UDP之中，从而绕过这一限制。这一技术被称为TCP over UDP。</p>
<p>从另一方面讲，基于UDP的VPN协议并不罕见，通过STUN打洞后完全可以建立一个基于UDP的虚拟局域网用于传递TCP数据包，例如传统的Wireguard协议。</p>
<p>此外，STUN可以利用TCP作为探测协议，但是在实际网络环境中并非所有NAT均为全锥NAT，因此TCP探测的成功率并不高。</p>
</blockquote>
<p>这是标准（RFC 3489）中的利用STUN来探测映射对和NAT类型的过程：</p>
<p><a href="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/2.png" data-fancybox="gallery" data-caption="图源来自维基百科">
            <img src="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/2.png" class="lazy" data-srcset="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="图源来自维基百科">
            </a></p>
<hr>
<h2 id="NAT2NAT-If-we-all-can-not-get-a-Public-IP"><a href="#NAT2NAT-If-we-all-can-not-get-a-Public-IP" class="headerlink" title="NAT2NAT - If we all can not get a Public IP"></a>NAT2NAT - If we all can not get a Public IP</h2><p>上面所讲述的内容，都是在拥有FullCone的前提下，内网穿透了自己的ip到公网上。然而在大多数使用场景内，我们并不需要把自己的ip暴露在公网上，而是需要两个内网用户之间能够直接链接。</p>
<p>而NAT2NAT技术可以很好的解决这一问题，N2N并不依赖于FullCone就可以尝试在两个NAT用户间“打洞”，使得两个内网用户“直接”互相链接，无需经过服务器转发。</p>
<blockquote>
<p>然而，拥有FullCone的打洞成功率接近100%，而其他类型的NAT打洞成功率则相对较低。</p>
</blockquote>
<p>这是一张表，阐述了不同类型NAT之间一般能否成功打洞</p>
<table>
<thead>
<tr>
<th>NAT类型</th>
<th>FullCone</th>
<th>RestrictedCone</th>
<th>PortRestrictedCone</th>
<th>Symmetric</th>
</tr>
</thead>
<tbody><tr>
<td>FullCone</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>RestrictedCone</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>PortRestrictedCone</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>X</td>
</tr>
<tr>
<td>Symmetric</td>
<td>√</td>
<td>√</td>
<td>X</td>
<td>X</td>
</tr>
</tbody></table>
<blockquote>
<p>打洞的成功率由大至小依次为：FullCone &gt; RestrictedCone &gt; PortRestrictedCone &gt; Symmetric。一般由打洞成功率高的NAT向打洞成功率低的NAT发起打洞请求，使弱势用户能够主动链接强势用户，便于弱势用户提前强势用户建立映射对。</p>
<p>受限锥-受限锥 受限端锥-受限端锥 需要任意一方在探测完后及时主动向对方发起链接，避免映射对被销毁。</p>
<p>对称型-端口受限锥型NAT之间的打洞成功率极低。(1&#x2F;65535)。</p>
<p>而对称型NAT之间的打洞成功率几乎为0。(1&#x2F;65535^2)</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/ntop/n2n">Ntop的N2N项目</a> 则是一个基于以上理论的开源项目，通过区分Edge(Client)和SuperNode(Server)的方式，方便了普通人的部署。</p>
<p>由于映射对本身只能在内网用户主动向外请求时才能建立，故如何将获取到的映射对及时传递给对方，是N2N的关键。而SuperNode在此时起到了关键作用，SuperNode会记录下所有Edge的映射对并分享给对方，使得两个Edge能够及时知晓对方的映射对，从而建立联系。</p>
<p>正常情况下，SuperNode并不参与数据传输，仅用于告知双方的映射对。然而，在双方NAT打洞成功率不高时，SuperNode也会回退为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TURN">TURN模式</a>（即传统方式，利用服务器转发流量，篇幅所限不再赘述）。</p>
<p>Linux用户可以直接下载<a target="_blank" rel="noopener" href="https://github.com/ntop/n2n/releases">N2N的二进制文件</a>，Windows与Mac用户则需要自行编译或使用第三方编译好的二进制文件。</p>
<p>对于我在Windows上的使用，我通常用<a target="_blank" rel="noopener" href="https://nullcraft.org/d/39-%E5%85%8D%E8%B4%B9-%E7%81%B5%E5%B7%A5%E8%89%BA%E7%BD%91%E4%B8%8A%E9%82%BB%E5%B1%85-nullcraft-n2n"> [灵工艺] 联机组网</a>。其有GUI可以快捷配置，并且也很方便安装TAP适配器。<del>主要是懒的敲命令行</del></p>
<p><a href="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/3.png" data-fancybox="gallery" data-caption="该图片无描述">
            <img src="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/3.png" class="lazy" data-srcset="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==">
            </a></p>
<p>首先搭建N2N需要有一台拥有公网ip的服务器，然后在服务器上运行SuperNode。尽管SuperNode正常情况下不参与数据传输，但是N2N无法主动禁用TURN模式，故不建议公开部署SuperNode。</p>
<p>搭建SuperNode可以直接安装N2N的二进制文件，配置文件存在<code>/etc/n2n/supernode.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># /etc/n2n/supernode.conf</span><br><span class="line">-p=1234</span><br></pre></td></tr></table></figure>

<p>运行<code>sudo systemctl start supernode</code>即可启动SuperNode，监听端口为1234。</p>
<p>如果需要开机自启动，可以运行<code>sudo systemctl enable supernode</code>。</p>
<p>如果当前运行环境（如Docker环境）不存在<code>systemctl</code>，可以自行下载N2N的项目源代码并自行编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ntop/n2n.git --depth=1</span><br><span class="line">bash ./autogen.sh</span><br><span class="line">bash ./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>然后采用<code>./supernode</code>的方式运行。</p>
<p>针对Edge，可以直接运行二进制文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo edge -c mynetwork -k mysecretpass -a 192.168.100.1 -f -l supernode.ntop.org:7777</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-c</code> 指定的链接组名，所有拥有相同链接组名的Edge会被视为同一组</li>
<li><code>-k</code> 指定的链接组密码</li>
<li><code>-a</code> 指定的内网ip</li>
<li><code>-l</code> 指定SuperNode的ip和端口</li>
</ul>
<p>在另一台Edge上运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo edge -c mynetwork -k mysecretpass -a 192.168.100.2 -f -l supernode.ntop.org:7777</span><br></pre></td></tr></table></figure>

<p>两台Edge将会自动建立链接，SuperNode会记录下两台Edge的映射对并分享给对方，使得两台Edge能够及时知晓对方的映射对，从而建立联系。</p>
<p>可以尝试在内网ip为<code>192.168.100.1</code>的Edge上运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 192.168.100.2</span><br></pre></td></tr></table></figure>

<p>应当会有相应的回应。</p>
<p><code>Ctrl+C</code>退出后，可以看到类似的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**********************************</span><br><span class="line"> Packet stats:</span><br><span class="line">       TX P2P: 10 pkts</span><br><span class="line">       RX P2P: 10 pkts</span><br><span class="line">       TX Supernode: 4 pkts (2 broadcast)</span><br><span class="line">       RX Supernode: 2 pkts (1 broadcast)</span><br><span class="line">**********************************</span><br></pre></td></tr></table></figure>

<p>其中<code>TX P2P</code>和<code>RX P2P</code>表示Edge之间的数据传输，<code>TX Supernode</code>和<code>RX Supernode</code>表示Edge与SuperNode的数据传输。</p>
<p>SuperNode的数据包应该远小于Edge之间的数据包，因为SuperNode仅用于告知双方的映射对，以及刚开始来不及打洞时通过<code>TURN</code>的数据传输。</p>
<p>如果经过一段时间后，<code>P2P</code>的数据包数仍然为0，说明N2N的打洞失败，应检查双方防火墙情况和NAT类型。</p>
<blockquote>
<p><strong>Tips:</strong></p>
<p>N2N的SuperNode默认允许了所有Edge的加入。尽管N2N官方有着<a target="_blank" rel="noopener" href="https://github.com/ntop/n2n/blob/dev/doc/Authentication.md">专门的鉴权方式</a>，但是配置及其麻烦，可以巧用<a target="_blank" rel="noopener" href="https://github.com/ntop/n2n/blob/dev/doc/Communities.md">限制通讯组</a>的方式，约定一个确定的通讯组名，限制只有拥有相同通讯组名的Edge才能加入。</p>
<p>修改<code>/etc/n2n/supernode.conf</code>，添加<code>-c</code>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># /etc/n2n/supernode.conf</span><br><span class="line">-p=1234</span><br><span class="line">-c=/etc/n2n/communities.list</span><br></pre></td></tr></table></figure>

<p>然后在<code>/etc/n2n/communities.list</code>中添加通讯组名(允许采用正则表达式，一行一个)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mynetwork</span><br></pre></td></tr></table></figure>

<p>重启SuperNode <code>sudo systemctl restart supernode</code> 即可生效。</p>
</blockquote>
<h2 id="How-to-Transform-Home-networks-to-get-FullCone-NAT"><a href="#How-to-Transform-Home-networks-to-get-FullCone-NAT" class="headerlink" title="How to Transform Home networks to get FullCone NAT"></a>How to Transform Home networks to get FullCone NAT</h2><blockquote>
<p>如果你已经拥有了公网IPV4，那么请直接略过这一节。</p>
</blockquote>
<h3 id="Disable-Firewall"><a href="#Disable-Firewall" class="headerlink" title="Disable Firewall"></a>Disable Firewall</h3><p>控制面板进入<code>高级安全 Windows Defender 防火墙</code>，在入站规则添加规则，<strong>允许</strong>所有端口的<code>UDP</code>。在出站规则中也如法炮制。</p>
<blockquote>
<p>为了安全性你也可以限定端口范围，但是这样会降低打洞成功率。</p>
<p>你不需要允许TCP协议，因为N2N默认采用的STUN探测协议为UDP。</p>
</blockquote>
<p><a href="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/4.png" data-fancybox="gallery" data-caption="该图片无描述">
            <img src="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/4.png" class="lazy" data-srcset="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==">
            </a></p>
<p><a href="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/5.png" data-fancybox="gallery" data-caption="该图片无描述">
            <img src="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/5.png" class="lazy" data-srcset="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==">
            </a></p>
<p><a href="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/6.png" data-fancybox="gallery" data-caption="该图片无描述">
            <img src="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/6.png" class="lazy" data-srcset="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==">
            </a></p>
<p><a href="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/7.png" data-fancybox="gallery" data-caption="该图片无描述">
            <img src="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/7.png" class="lazy" data-srcset="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==">
            </a></p>
<p>如果你使用的是第三方防火墙，也请关闭防火墙或者添加规则。</p>
<h3 id="Enable-DMZ-host"><a href="#Enable-DMZ-host" class="headerlink" title="Enable DMZ host"></a>Enable DMZ host</h3><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/DMZ">DMZ技术</a>，Demilitarized Zone的缩写，是一种网络安全技术，用于将内部网络与外部网络隔离开来。而对于家庭网络而言，DMZ主机的则是路由器将所有端口的流量都转发到这台主机上。</p>
<blockquote>
<p>在严格意义上，DMZ与内部网络是隔离的，但是在家庭网络中，DMZ主机仍然可以访问内网，而内网用户也可以访问DMZ主机。</p>
</blockquote>
<p>在路由器设置中，找到DMZ主机设置，将你的电脑ip设置为DMZ主机。</p>
<p>首先查询自己电脑的内网ip地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure>

<p><a href="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/8.png" data-fancybox="gallery" data-caption="该图片无描述">
            <img src="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/8.png" class="lazy" data-srcset="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==">
            </a></p>
<p>记下地址为<code>192.168.31.215</code></p>
<p>以我的小米路由器为例，登录路由器后台，找到<code>高级设置</code>-<code>端口转发</code>-<code>DMZ主机</code>，将地址填入：</p>
<p><a href="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/9.png" data-fancybox="gallery" data-caption="该图片无描述">
            <img src="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/9.png" class="lazy" data-srcset="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==">
            </a></p>
<p>保存即可。</p>
<blockquote>
<p>如果你的路由器不支持DMZ主机设置，可以尝试将你的电脑设置为静态ip，并将所有的UDP端口转发到你的电脑上。</p>
</blockquote>
<h3 id="Change-to-Bridge"><a href="#Change-to-Bridge" class="headerlink" title="Change to Bridge"></a>Change to Bridge</h3><p>目前的家庭网络通常是 光纤入户 -&gt; 运营商提供的智能网关 -&gt; 用户路由器 -&gt; 用户电脑的结构。其中智能网关通常是光猫+路由器+AP的缝合怪。按照大部分地区的安装指导，光猫默认会工作在NAT模式下，以便于用户能够直接使用，而无需拨号。</p>
<p>然而，大部分光猫NAT的策略都默认设置为对称性NAT，即使光猫拥有DMZ主机设置，最终NAT类型也是对称性NAT。</p>
<p>因此，我们需要将智慧网关设置为桥接模式（工作在仅光猫状态），将路由器设置为拨号上网，再在路由器上设置DMZ主机。</p>
<blockquote>
<p>是不是看起来很怪？事实上大部分家庭网络都是FullCone NAT，但是由于智慧网关的NAT策略，使得家庭网络的NAT类型变为了对称性NAT。</p>
</blockquote>
<p>将智慧网关设置为桥接状态，通常需要获取光猫的超级管理员密码，然后删除原有的配置，新建新的桥接配置，并在下一级的路由器上设置拨号上网。</p>
<p>由于篇幅所限，这里不再赘述具体的操作步骤。光猫的具体破解方式各异，可以尝试自行搜索<code>XXX-XX型号光猫改桥接</code>。</p>
<hr>
<p>通常来讲，设置好桥接 - 设置DMZ主机 - 关闭防火墙后，你的家庭网络应该已经变为了FullCone NAT。此时不妨利用pystun3测试一下你的NAT类型。如果已经为FullCone，那么恭喜你。如果没有，那么你当地的运营商很可能对网络进行了限制。</p>
<h2 id="So-why-I-prefer-FullCone-NAT"><a href="#So-why-I-prefer-FullCone-NAT" class="headerlink" title="So, why I prefer FullCone NAT"></a>So, why I prefer FullCone NAT</h2><p>第一个原因是，相对于公网IPV4，FullCone的改造更为廉价和安全。在大多数地区，公网IPV4的价格昂贵，而且公网IPV4的暴露会使得内网用户的安全性大大降低。<del>此外，移动运营商由于本身v4资源匮乏，绝大多数地区已经不再提供公网IPV4</del></p>
<p>此外，相较于IPV6，传统的IPV4的网络设备更为成熟，出门在外想要连回家里的网络，如果没有IPV6，那么还得要绕道服务器转发。</p>
<p>相对于传统服务器内网穿透，直接点对点链接的优势无疑是巨大的，最终双方的访问质量仅取决于双方的网络质量，而不再受到服务器的限制。（比如我在外就可以直接跑满家庭上行100M，而不是服务器龟速5M上行，这使得远程串流游戏成为了可能）</p>
<p>回到文章的刚开始，由于我拥有了FullCone NAT，当MC服务器启动在我电脑后，通过N2N软件，朋友的客户端能够直接链接到我的电脑上。由于我们过年回家都在台州，相互之间直接连接的质量也相较于内网穿透的质量高上不少。</p>
<blockquote>
<p>尽管N2N不需要FullCone也有一定概率能够打洞，但是FullCone就是爽</p>
</blockquote>
<p>然而除此之外，如果对FullCone网络进行恰当的改造，那么我就能在无法拥有公网ip（毕竟是移动）的情况下，享受公网ip的待遇。访问效果上等同于拥有了一组公网IP:端口。</p>
<h3 id="Export-My-Server-to-Public-Internet"><a href="#Export-My-Server-to-Public-Internet" class="headerlink" title="Export My Server to Public Internet"></a>Export My Server to Public Internet</h3><p>先前我的脚本已经证明，FullCone网络在通过恰当的方式打洞后，能够直接将内网ip暴露在公网上。事实上，Github已经有类似的项目能够探测FullCone NAT的映射对的程序，例如<a target="_blank" rel="noopener" href="https://github.com/heiher/natmap">NATMAP</a> 和 <a target="_blank" rel="noopener" href="https://github.com/MikeWang000000/Natter">Natter</a>。</p>
<p>其中，NATMAP基于C++，暂时还不支持Windows。而Natter则是基于Python的，支持Windows（但截至本文发稿时Windows上UDP穿透仍存在严重的问题），也支持流量转发（由于探测需要临时占用端口，而部分程序无法解除端口占用，故可以新开一个随机端口用于探测，然后将探测端口流量转发到目标端口即可）。</p>
<p>事实上，你可以利用NATMAP或Natter探测到的映射对记录映射对，并通过其他简易的内网穿透或者定时上传到公开网站的方式，实现一个简单的DDNS。</p>
<blockquote>
<p>另一方面，DNS记录中存在名为SRV的记录类型，可以指定端口。如果你拥有一个域名，那么你可以通过SRV记录将你的映射对共享出去。</p>
<p>与DDNS技术相比，通过FullCone打洞仅仅多了一个端口的记录。</p>
</blockquote>
<blockquote>
<p>此外，截至本文发稿时，Natter“固定”映射对的效果尚不如NATMAP，在关闭程序后映射对可能会发生改变，但是Natter的配置更加方便，也支持流量转发。</p>
</blockquote>
<p>通过这种方式，我已经成功将我的服务器Wireguard入口暴露到了公网上，至此，我可以在不购买公网IPV4、无IPV6的情况下，在任何地方通过我的服务器访问到我的家庭网络。</p>
<p>至于其他的RDP、SSH等服务，也可以通过类似的方式实现。不过建议还是只暴露Wireguard入口，然后通过Wireguard内网穿透到其他服务。<del>毕竟安全第一</del></p>
<h3 id="Get-A-HighID-in-P2P-download"><a href="#Get-A-HighID-in-P2P-download" class="headerlink" title="Get A HighID in P2P download"></a>Get A HighID in P2P download</h3><p>在电驴下载中，存在这<code>LowID</code>和<code>HighID</code>的概念。<code>LowID</code>是指没有公网IPV4的用户，而<code>HighID</code>则是指拥有公网的用户。两个<code>LowID</code>之间无法直接链接，但是<code>HighID</code>可以直接链接到<code>LowID</code>和<code>HighID</code>。</p>
<p>在其他P2P下载中，也存在类似的概念。放到PT下载中，拥有一个<code>LowID</code>的用户，相对于<code>HighID</code>用户而言，下载速度会大大降低。同时，<code>LowID</code>用户在做种时也无法主动链接到其他<code>LowID</code>用户，从而影响了共享效果，在PT上传中很难抢到上传流量。</p>
<p>然而，通过FullCone NAT，我可以将我的PT客户端的端口暴露在公网上，从而获得了<code>HighID</code>。但是在这其中存在一个问题，映射对中内网端口和外网端口通常是不一致的，而PT客户端向Tracker服务器报告的端口是内网端口，外网用户无法用（公网ip:内网端口）访问到我的PT客户端。</p>
<p>因此，需要先随机探测一个映射对，记录（内网ip:内网随机端口）和（公网ip:外网端口）的对应关系，并新建一个转发，将（内网ip:内网随机端口）的流量转发到（内网ip:外网端口），并通过BT客户端的API修改BT程序监听端口为外网端口。通过这种方式，使BT客户端向Tracker服务器报告的端口为外网端口，从而获得了<code>HighID</code>。</p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/ChenYFan/8b5ba92875a195a992c7d451490971e4">这是我之前不知道在那个论坛抄下来的脚本</a>，可利用natmap或natter的script功能自动修改BT客户端的监听端口并转发流量，出处已不可考。</p>
<hr>
<p>到这里为止，FullCone NAT好像已经变得完美无瑕，它拥有着相对于公网v4极高的性价比，并且有着丰富的DIY内容。这篇文章在这里应该已经结束了</p>
<p>…吗？</p>
<h2 id="It-is-Hard-to-Get-a-FullCone-NAT"><a href="#It-is-Hard-to-Get-a-FullCone-NAT" class="headerlink" title="It is Hard to Get a FullCone NAT"></a>It is Hard to Get a FullCone NAT</h2><p>你并没有那么容易获得全锥网络。由于大部分运营商的光猫已经被逐步替换为了智能网关，破解智能网关本身就具有这相当高的难度。</p>
<blockquote>
<p>我知道你想说什么，花了150的租金，拿了个什么都缝合了、什么都没缝合好的电子垃圾。wifi只有2.4G不支持5G，不支持在NAT中下发公网IPV6，大部分功能被运营商锁定不让你用，甚至还有<a target="_blank" rel="noopener" href="https://v2ex.com/t/952671">远控后门</a>。</p>
</blockquote>
<p>此外，不像我手上的移动H3-2se智能网关有着开启telnet的漏洞，大部分智能网关想要获取超管密码都极为困难，想要破解获得密码还得根据型号来选择方式。部分机型还需要替换备份包的方式刷机，稍有不慎就会出现意外，破解的难度极高。</p>
<p>另一方面，运营商显然是不希望用户改为桥接模式的。</p>
<p>首先，<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/587820301">按照知乎上的普遍说法</a>，改桥接意味着运营商将丢失对光猫的远程控制，一旦用户家庭网络出现问题，则无法远程解决，需要安装师傅上门，浪费人力物力。</p>
<blockquote>
<p>事实上，相对于智能网关即插即用的特性，改为桥接需要用户在路由器或者在电脑上拨号。这对于不了解网络的用户来说是一件很麻烦的事情，免不了请人帮忙安装。</p>
</blockquote>
<p>其次，桥接模式意味着用户可以自行选择路由器，而不再受限于运营商提供的智能网关，运营商则无法在终端网络上提供额外的审查能力。</p>
<p>此外，一旦改为桥接，<a target="_blank" rel="noopener" href="https://www.v2ex.com/t/887345">部分地区的运营商还会降速</a>，（尽管不排除光猫性能羸弱可能性）。</p>
<p>最重要的原因是，运营商它怕你占用了大量的<strong>上行</strong>带宽…</p>
<h3 id="ISP-is-Afraid-of-PCDN"><a href="#ISP-is-Afraid-of-PCDN" class="headerlink" title="ISP is Afraid of PCDN"></a>ISP is Afraid of PCDN</h3><p>PCDN，Peer-to-Peer Content Delivery Network，即点对点内容分发网络。</p>
<p>这个名词在普通网络中并不常用，但国内诸多互联网厂商对此并不陌生。由于大陆政策的商宽补贴家宽的特性，相较于国外家宽的价格，国内家宽的价格极为便宜。</p>
<p>然而如此一来，宽带成本压力就转嫁到了商宽上，云服务厂商接入ISP的价格极其昂贵（国内网盘业务难以发展的原因之一）。类似视频分发等业务，如果全部由云服务厂商提供，那么运营成本将会难以负担。</p>
<p>于是各大国内服务商就走起了歪路，PCDN这一邪门技术便应运而生。PCDN的核心思想是，用户之间互相分享资源，从而减轻服务器的存储压力和带宽压力。</p>
<p>通常来讲，用户可以主动作为pcdn节点共享带宽，从而向服务商赚取少量佣金。服务商只要付出极少成本，就能够获得遍布在广大用户间海量存储和带宽资源。先前百度网盘试图开放<code>闲置宽带优化计划</code>，也是PCDN的一种。<del>当然你白开一年PCDN换取到的奖励也是微乎其微的</del></p>
<blockquote>
<p>服务商的打洞方式当然也包括N2N打洞。事实上服务商的客户端程序打洞的方式可能更多更狠，本文仅涉猎了其中一种方式。</p>
</blockquote>
<p>然而，<a target="_blank" rel="noopener" href="https://www.v2ex.com/t/945773">有一些软件可能会自己偷偷摸摸跑PCDN</a>，用户很大概率是无感的（毕竟XX视频、XX音乐、XX网盘客户端上传都是限速的，以避免大量占用资源而被察觉）。<del>太离谱了还是会被发现的</del></p>
<p>自然，运营商是极其不乐意的，PCDN固然<strong>降低了服务商的压力</strong>，但这些压力分毫不少的转移到了运营商的头上，运营商从服务商<strong>收取的钱变少了</strong>，还<strong>承担了相同（甚至更多的）带宽压力</strong>。</p>
<p>但是，运营商的骨干网络通常没有做单独的限制，通过改造骨干网络来限制PCDN显得不太现实。因此运营商只能在终端网络上下手。而在智能光猫内植入限制，是最为方便的方式。</p>
<blockquote>
<p>这就是为什么当我们解除了终端智能光猫的限制后，NAT类型通常都还原回了FullCone。</p>
</blockquote>
<blockquote>
<p>但是，部分地区运营商检测到用户如果在偷跑PCDN（不管是不是故意的）或者长时间大规模占用上行带宽，会针对性地对用户上行进行限速，或者将用户NAT降级为对称性NAT。</p>
</blockquote>
<p>一旦开启桥接，诸多互联网厂商软件会直接开始吸血家宽。由于国内宽带通常计费方式是包年计带宽，不计流量，因此用户可能完全不会察觉到PCDN的开启，但运营商则会为此承担更多的带宽压力。</p>
<blockquote>
<p>此外，运营商对BT等P2P下载也是深恶痛绝的，但是彻底根除显得并不现实，因此运营商只能通过劣化互联质量降低上传宽带的占用。</p>
</blockquote>
<hr>
<p>NAT的发明极大减缓了全球IPV4地址枯竭的难题，它允许了多个网络设备共享一个公网IPV4地址。然而现如今，IPV6的时代已经到来，NAT却成为了IPV6发展的障碍。究其原因，是因为NAT设立之初并没有考虑计划淘汰 - 它可以一直永远的工作下去。</p>
<blockquote>
<p>并且，NAT通常也用于隔离内部网络和外网，即使是在IPV6中也会存在NATv6确保内网用户的安全性。</p>
</blockquote>
<p>然而，由于NAT的设计阻碍了不同内部网络双方的直接通讯 - 即使双方并不想在内部网络，但由于IPV4的枯竭，他们不得不用，这使得类似于物联网、智能汽车等需要<strong>万物互联</strong>新兴技术受到了阻碍。即使物联网设备用上了IPV6 - 你能确保走出门外，随便接入一个wifi都有IPV6吗？</p>
<p>一个听起来令人发笑的事实是，8年前的无线路由器依旧在我家工作的很好 - 它支持802.11ac(5GHz)，提供了和外网带宽匹配的无线带宽速率。<strong>它只是不支持IPV6</strong>。</p>
<p>我有必要换它吗？我不认为，因为在我实际上网过程中，纯IPV6的网站并不多；家里人也不需要所谓的IPV6，因为他们的需求仅仅是看视频和上网购物；家里设备也不需要IPV6，因为这种小型家庭监控、冰箱、扫地机器人通常是通过物联网卡上网的，即使连接WIFI，也是通过云服务商提供的服务来访问的。</p>
<p>它只要能正常工作，<strong>这就够了</strong>。</p>
<p>现在我想在我家放一台NAS，我的需求是能在离开家之后随时随地访问这台NAS。那么，纯IPV6也不能满足我的需求，因为我不能保证我在外面的网络环境拥有IPV6 - 是的，因为不支持IPV6的网络设施依旧能在纯IPV4的网络环境下工作，为什么一定要淘汰它呢？</p>
<p>纵然国家大力支持发展IPV6，但是在实际民用网络应用中，IPV6的普及率依旧很低，终端设备（家庭网关、无线路由器）的淘汰问题成为了IPV6普及的最大障碍。此外，部分地区运营商甚至把IPV6与公网IPV4对立，声称为了<a target="_blank" rel="noopener" href="https://www.189.cn/sc/sy_ycgg/118104.html">普及IPV6而开始对公网IPV4收费</a>，并借机<a target="_blank" rel="noopener" href="https://www.v2ex.com/t/875867">利用NAT4444实现假公网V4</a>。</p>
<p><a href="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/2.jpg" data-fancybox="gallery" data-caption="该图片无描述">
            <img src="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/2.jpg" class="lazy" data-srcset="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174784/files/data/npm/chenyfan-os/0.0.0-r25/files/article/2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==">
            </a></p>
<blockquote>
<p>与其花399购买一个静态FullCone网络，不如免费白嫖动态FullCone网络</p>
</blockquote>
<p>另外，正如我之前提到的，家庭网络绝大多都是FullConeNAT，如果有足够的折腾精神，改造光猫对我而言并不困难。</p>
<p>事实上，我现在在自己的NAS上就同时部署了两种穿透方案，一种是FRP，另一种是用利用NATMAP探测并将探测到的映射记录同步到DNS的SRV记录上。通过这种方式，我可以在任何地方直接用Wireguard连回家，除非遇到故障才会去用FRP。</p>
<hr>
<p>这就是FullCone NAT，它一直存在于我们生活中，并且仍具有极高的利用价值。如果能够合理的利用它，我想节省下一笔关于公网IPV4的费用，也不是不可能的。</p>
<p>只是可惜，在如今运营商政策的收紧、光猫破解变得越来越难的趋势下，FullCone NAT的普及率将只会变得越来越低。</p>
<p>在写下本篇文章的最后一段时，我想等到数年后IPV6彻底普及，会不会有人看完这篇文章会嘲笑，在2024年的时候，还有一个傻子拒绝公网IPV6，还在尝试使用已经宣告缓刑的IPV4进行“万物互联”呢？</p>
<p>这里是CyanFalse的小站，一个小小的年更博客，感谢您的阅读。</p>

    </div>
    
    <div class="divider"></div>
    <div class="container post-prev-next">
        <a class="next"></a>
        
        <a href="/p/e73f73cf.html" class="prev">
            <div>
                <div class="text">
                    <p class="label">上一篇</p>
                    <h3 class="title">笔记本安装Ubuntu+Win10双系统疑难杂症记录</>
                </div>
            </div>
        </a>
        
    </div>
    <div class="divider"></div>
    
    <div class="about">
        <h1>关于本文</h1>
        <div class="details">
            <p>由 CyanFalse 撰写, 采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a> 许可协议.</p>
        </div>
        
        <p class="tags text-capitalize">
            
            <a href="/tags/黑科技/" class="tag"><svg t="1689914194799" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1646" id="mx_n_1689914194800" width="14" height="14"><path d="M483.2 790.3L861.4 412c1.7-1.7 2.5-4 2.3-6.3l-25.5-301.4c-0.7-7.8-6.8-13.9-14.6-14.6L522.2 64.3c-2.3-0.2-4.7 0.6-6.3 2.3L137.7 444.8c-3.1 3.1-3.1 8.2 0 11.3l334.2 334.2c3.1 3.2 8.2 3.2 11.3 0z m122.7-533.4c18.7-18.7 49.1-18.7 67.9 0 18.7 18.7 18.7 49.1 0 67.9-18.7 18.7-49.1 18.7-67.9 0-18.7-18.7-18.7-49.1 0-67.9z" p-id="1647" fill="#1296db"></path><path d="M889.7 539.8l-39.6-39.5c-3.1-3.1-8.2-3.1-11.3 0l-362 361.3-237.6-237c-3.1-3.1-8.2-3.1-11.3 0l-39.6 39.5c-3.1 3.1-3.1 8.2 0 11.3l243.2 242.8 39.6 39.5c3.1 3.1 8.2 3.1 11.3 0l407.3-406.6c3.1-3.1 3.1-8.2 0-11.3z" p-id="1648" fill="#1296db"></path></svg>黑科技</a><a href="/tags/网络/" class="tag"><svg t="1689914194799" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1646" id="mx_n_1689914194800" width="14" height="14"><path d="M483.2 790.3L861.4 412c1.7-1.7 2.5-4 2.3-6.3l-25.5-301.4c-0.7-7.8-6.8-13.9-14.6-14.6L522.2 64.3c-2.3-0.2-4.7 0.6-6.3 2.3L137.7 444.8c-3.1 3.1-3.1 8.2 0 11.3l334.2 334.2c3.1 3.2 8.2 3.2 11.3 0z m122.7-533.4c18.7-18.7 49.1-18.7 67.9 0 18.7 18.7 18.7 49.1 0 67.9-18.7 18.7-49.1 18.7-67.9 0-18.7-18.7-18.7-49.1 0-67.9z" p-id="1647" fill="#1296db"></path><path d="M889.7 539.8l-39.6-39.5c-3.1-3.1-8.2-3.1-11.3 0l-362 361.3-237.6-237c-3.1-3.1-8.2-3.1-11.3 0l-39.6 39.5c-3.1 3.1-3.1 8.2 0 11.3l243.2 242.8 39.6 39.5c3.1 3.1 8.2 3.1 11.3 0l407.3-406.6c3.1-3.1 3.1-8.2 0-11.3z" p-id="1648" fill="#1296db"></path></svg>网络</a><a href="/tags/NAT/" class="tag"><svg t="1689914194799" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1646" id="mx_n_1689914194800" width="14" height="14"><path d="M483.2 790.3L861.4 412c1.7-1.7 2.5-4 2.3-6.3l-25.5-301.4c-0.7-7.8-6.8-13.9-14.6-14.6L522.2 64.3c-2.3-0.2-4.7 0.6-6.3 2.3L137.7 444.8c-3.1 3.1-3.1 8.2 0 11.3l334.2 334.2c3.1 3.2 8.2 3.2 11.3 0z m122.7-533.4c18.7-18.7 49.1-18.7 67.9 0 18.7 18.7 18.7 49.1 0 67.9-18.7 18.7-49.1 18.7-67.9 0-18.7-18.7-18.7-49.1 0-67.9z" p-id="1647" fill="#1296db"></path><path d="M889.7 539.8l-39.6-39.5c-3.1-3.1-8.2-3.1-11.3 0l-362 361.3-237.6-237c-3.1-3.1-8.2-3.1-11.3 0l-39.6 39.5c-3.1 3.1-3.1 8.2 0 11.3l243.2 242.8 39.6 39.5c3.1 3.1 8.2 3.1 11.3 0l407.3-406.6c3.1-3.1 3.1-8.2 0-11.3z" p-id="1648" fill="#1296db"></path></svg>NAT</a><a href="/tags/内网穿透/" class="tag"><svg t="1689914194799" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1646" id="mx_n_1689914194800" width="14" height="14"><path d="M483.2 790.3L861.4 412c1.7-1.7 2.5-4 2.3-6.3l-25.5-301.4c-0.7-7.8-6.8-13.9-14.6-14.6L522.2 64.3c-2.3-0.2-4.7 0.6-6.3 2.3L137.7 444.8c-3.1 3.1-3.1 8.2 0 11.3l334.2 334.2c3.1 3.2 8.2 3.2 11.3 0z m122.7-533.4c18.7-18.7 49.1-18.7 67.9 0 18.7 18.7 18.7 49.1 0 67.9-18.7 18.7-49.1 18.7-67.9 0-18.7-18.7-18.7-49.1 0-67.9z" p-id="1647" fill="#1296db"></path><path d="M889.7 539.8l-39.6-39.5c-3.1-3.1-8.2-3.1-11.3 0l-362 361.3-237.6-237c-3.1-3.1-8.2-3.1-11.3 0l-39.6 39.5c-3.1 3.1-3.1 8.2 0 11.3l243.2 242.8 39.6 39.5c3.1 3.1 8.2 3.1 11.3 0l407.3-406.6c3.1-3.1 3.1-8.2 0-11.3z" p-id="1648" fill="#1296db"></path></svg>内网穿透</a>
        </p>
        
    </div>
    

    

    
        <div class="content container about" style="margin:8px auto">
            <div id="Comments">
                <p style="align-items: center;text-align: center;" id="comment_notice">Wait...</p>
            </div>
        </div>
        
</article>

        <footer>
    <div class="inner">
        <div class="links">
            
        </div>
        <span>&copy; 2024
                CyanFalse<br> </span>
                <span>Hexo Powered | NPMMirror CDN Supported</span></br>
                <span>浙ICP备2023021315号-2</span></div>
        

    </div>
</footer>
        <script async src="https://umami.eurekac.cn/script.js" data-website-id="8be37a45-1387-4cd9-86ae-7fd3d33e8c29"></script>
        <script src="https://registry.npmmirror.com/@chenyfan/cache-db/0.0.4/files/index.js"></script>
        <!-- FancyBox -->
        
        <script src="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174143/files/data/npm/@fancyapps/ui/4.0.31/files/dist/fancybox.umd.js"></script>
        
        <script src='/js/main.js'></script>
        
        
        
        <script src="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174143/files/data/npm/pagemap/1.4.0/files/dist/pagemap.min.js"></script>
        <script src="https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174143/files/data/npm/notyf/3.10.0/files/notyf.min.js"></script>
        <script>
            window.notyf = new Notyf({
                duration: 3000,
                position: {
                    x: 'right',
                    y: 'bottom'
                },
                ripple: true,
                dismissible: true
            });
            window.importJS = async (url) => {
                return new Promise((resolve, reject) => {
                    let script = document.createElement('script')
                    script.src = url
                    script.onload = () => {
                        resolve()
                    }
                    script.onerror = () => {
                        reject()
                    }
                    document.head.appendChild(script)
                })

            }
            window.importCSS = async (url) => {
                return new Promise((resolve, reject) => {
                    let link = document.createElement('link')
                    link.rel = 'stylesheet'
                    link.href = url
                    link.onload = () => {
                        resolve()
                    }
                    link.onerror = () => {
                        reject()
                    }
                    document.head.appendChild(link)
                })
            };
            (async () => {
                if (!!document.getElementById("Comments")){
                    const data = JSON.parse((await db.read("CommentSetting")) || JSON.stringify({
                    enable: true,
                    delay: 5
                }))
                if (data.enable) {
                    document.getElementById("comment_notice").innerText = "Comment Will Load After " + data.delay + "s"
                    setTimeout(() => {
                        const wait_comment_load = setInterval(async () => {
                            if (isElementVisible(document.getElementById("Comments"))) {
                                clearInterval(wait_comment_load)
                                document.getElementById("comment_notice").innerText = "Loading Comment Script..."
                                await loadJS("https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174143/files/data/npm/artalk/2.8.2/files/dist/Artalk.js")
                                document.getElementById("comment_notice").innerText = "Loading Comment Style..."
                                await loadCSS("https://registry.npmmirror.com/@chenyfan/npm-autosync/0.0.0-1729174143/files/data/npm/artalk/2.8.2/files/dist/Artalk.css")
                                document.getElementById("comment_notice").innerText = "Loading Comment Frame..."
                                window.artalk = Artalk.init({
                                    el: '#Comments',
                                    pageKey: window.location.pathname,
                                    pageTitle: "",
                                    server: 'https://artalk.eurekac.cn',
                                    site: 'CyanFalseの幻想乡♂'
                                })
                                artalk.setDarkMode(window.darkMode)
                            }
                        }, 1000)
                    }, data.delay*1000)
                } else {
                    document.getElementById("comment_notice").innerText = "Comment Disabled by Your Config"
                }
                const isElementVisible = (el) => {
                    const rect = el.getBoundingClientRect()
                    const vWidth = window.innerWidth || document.documentElement.clientWidth
                    const vHeight = window.innerHeight || document.documentElement.clientHeight
                    if (
                        rect.right < 0 ||
                        rect.bottom < 0 ||
                        rect.left > vWidth ||
                        rect.top > vHeight
                    ) {
                        return false
                    }

                    return true
                }
                }
                if (!!document.querySelector('#map')) {
                    window.loadPageMap = (dark) => {
                        document.querySelector('#map').id = 'map-predelete'
                        let newMap = document.createElement('canvas')
                        newMap.id = 'map'
                        document.querySelector('#map-predelete').insertAdjacentElement('afterend', newMap)
                        document.querySelector('#map-predelete').remove()
                        let initColor = dark ? '255,255,255' : '0,0,0'
                        pagemap(document.querySelector('#map'), {
                            viewport: null,
                            styles: {
                                'header,footer,section,article': 'rgba(' + initColor + ',0.08)',
                                'h1': 'rgba(' + initColor + ',0.10)',
                                'h2,h3,h4': 'rgba(' + initColor + ',0.08)',
                                'pre': 'rgba(' + initColor + ',0.05)'
                            },
                            back: 'rgba(' + initColor + ',0.02)',
                            view: 'rgba(' + initColor + ',0.05)',
                            drag: 'rgba(' + initColor + ',0.10)',
                            interval: null
                        });
                        document.querySelector('#map').addEventListener('mouseover', () => {
                            document.querySelector('#map').classList.remove('fadeout')
                            document.querySelector('#map').classList.add('fadein')
                        });
                        document.querySelector('#map').addEventListener('mouseout', () => {
                            document.querySelector('#map').classList.remove('fadein')
                            document.querySelector('#map').classList.add('fadeout')
                        });
                        let map = document.querySelector('#map')
                        let mapTimeout = null
                        document.addEventListener('scroll', () => {
                            map.classList.remove('fadeout')
                            map.classList.add('fadein')
                            if (mapTimeout) clearTimeout(mapTimeout)
                            mapTimeout = setTimeout(() => {
                                map.classList.remove('fadein')
                                map.classList.add('fadeout')
                            }, 1000)
                        })
                    }
                    loadPageMap(window.darkMode, true)
                }

                window.db = new CacheDB('CyanAcc', "CyanAccDB")
                if (await db.read('needInstall') === 'never') {
                    console.log('CyanAcc已禁用')
                    return;
                }
                if ('serviceWorker' in navigator) {
                    if (await db.read('install_time') === null ||
                        new Date().getTime() > Number(await db.read('install_time')) + 1000 * 60 * 60 * 4) {
                        await db.write('install_time', new Date().getTime())
                        await db.write('needInstall', 'true')
                    }
                    if (await db.read('needInstall') === 'true') {
                        navigator.serviceWorker.register(`/CyanAcc.js?time=${new Date().getTime()}`)
                            .then(async reg => {
                                let error = 0
                                const CyanAcc_Checker = setInterval(() => {
                                    fetch('/CyanAcc/api', {
                                        method: 'POST',
                                        body: JSON.stringify({
                                            action: 'PING'
                                        })
                                    })
                                        .then(res => res.json())
                                        .then(async res => {
                                            if (res.data === "PONG") {
                                                notyf.success('CyanAcc安装/更新成功<br/>建议刷新以启用CyanAcc！')
                                                clearInterval(CyanAcc_Checker)
                                                await db.write('needInstall', 'false')
                                            }
                                        })
                                        .catch(err => {
                                            console.log(`CyanAcc检查失败，正在重试第${error}次`)
                                            error++
                                            if (error > 10) {
                                                notyf.error({
                                                    message: `CyanAcc安装后无成功响应！将不会再尝试安装！</br>正在卸载已安装的CyanAcc...</br>详细信息请查看控制台`,
                                                    duration: 10000
                                                })
                                                console.error(err)
                                                clearInterval(CyanAcc_Checker)
                                                db.write('needInstall', 'never')
                                                reg.unregister()
                                            }
                                        })
                                }, 1000);
                            }).catch(async err => {
                                notyf.error({
                                    message: `CyanAcc安装失败！</br>将不会再尝试启动CyanAcc</br>请点击右上角设置手动安装</br>详细信息请查看控制台`,
                                    duration: 10000
                                })
                                console.error(err)
                                await db.write('needInstall', 'never')
                            })
                    } else {
                        console.log('CyanAcc暂时无需更新，正在获取脚本与样式注入')
                        await importJS('/CyanAcc/custom.js?time=' + new Date().getTime())
                        console.log('CyanAcc脚本注入成功')
                        await importCSS('/CyanAcc/custom.css?time=' + new Date().getTime())
                        console.log('CyanAcc样式注入成功')
                    }
                } else {
                    if (location.protocol !== 'https:') notyf.error('请使用HTTPS协议以启用CyanAcc')
                    else {
                        notyf.error('您的浏览器不支持或被广告插件禁用ServiceWorker</br>已直接禁用CyanAcc')
                        await db.write('needInstall', 'never')
                    }
                }
            })();
        </script>
        
    </body>
</html>